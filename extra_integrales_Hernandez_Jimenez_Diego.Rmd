---
title: "Extra integrales"
author: 'Diego Hernández Jiménez'
output: pdf_document
---

Objetivo: construir función que permita obtener la integral definida de una función sobre un intervalo dado.
<p>&nbsp;</p>
**integral_definida()**

* Descripción: aproxima la integral definida de una función sobre [a,b], dado un número de particiones.

* Argumentos:

  - ```funcion```: class=function. Función matemática que queremos integrar.
  
  - ```a```: class=numeric. Límite inferior de integración.
  
  - ```b```: class=numeric. Límite superior de integración.
  
  - ```n```: class=numeric. Número de particiones.
  
  - ```aprox```: class=character. Técnica de integración elegida. La integral definida se puede aproximar mediante rectángulos             (```'rect'```), la regla de los trapecios (```'trap'```) o mediante la regla de Simpson (```'simp'```). Ésta última proporciona las mejores        aproximaciones, pero cuando n es un número par. 
  <p>&nbsp;</p>
      Aproximación por rectángulos: $\displaystyle \int_a^b  f(x)\,dx = \lim_{n\rightarrow \infty}  I_n=\lim_{n\rightarrow \infty}S_n$.
      
      $In=\sum_{i=1}^n f(m_i)\cdot (\frac{b-a}{n})$ ; $Sn=\sum_{i=1}^n f(M_i)\cdot (\frac{b-a}{n})$
      <p>&nbsp;</p>
      Regla de los trapecios:  $\displaystyle \int_a^b f(x)\, dx \approx \frac{b-a}{2n}[f(x_0) + 2f(x_1) + 2f(x_2) + 2f(x_3) + ... + 2f(x_{n-2}) + 2f(x_{n-1}) + f(x_n)]$<p>&nbsp;</p>
      Regla de Simpson:  $\displaystyle \int_a^b f(x)\, dx \approx \frac{b-a}{3n}[f(x_0) + 4f(x_1) + 2f(x_2) + 4f(x_3) + ... + 2f(x_{n-2}) + 4f(x_{n-1}) + f(x_n)]$
  
* Devuelve:
  - Si ```aprox='rect'```: lista con dos elementos class=numeric que representan la suma inferior (In) y la suma superior (Sn)
  
  - Si ```aprox='trap'``` o ```aprox='simp'```: vector de longitud uno que representa la estimación de la integral definida sobre a y      b.  Class=numeric
```{r}

integral_definida <- function(funcion,a,b,n,aprox='rect'){

  interv <- (b-a)/n
  
  seg <- seq(from=a,to=b,by=interv)
  
  if (aprox=='trap'){
    
    strt_end <- c(funcion(seg[1]),funcion(seg[n+1]))
    mid <- 2*funcion(seg[2:n])
    
    return(( (b-a)/(2*n) )*sum(strt_end,mid))
  }
  else if (aprox=='simp'){
    
    strt_end <- c(funcion(seg[1]),funcion(seg[n+1]))
    seg_cut <- seg[2:n]
    
    indices <- 1:length(seg_cut)
    mid <- c(4*funcion(seg_cut[indices%%2 != 0]),
             2*funcion(seg_cut[indices%%2 == 0]))
    
    return(( (b-a)/(3*n) )*sum(strt_end,mid))
  }
  else{
    
    In <- double(1)
    Sn <- double(1)
  
    for (i in 1:n){
      fmi <- min(funcion(seg[i]:seg[i+1]))
      In <- In+fmi*interv
      fMi <- max(funcion(seg[i]:seg[i+1]))
      Sn <- Sn+fMi*interv
    }
    return(list(In=In,Sn=Sn))
  }
}

integral_definida(dnorm,0,1.5,10)
```
Estos resultados parecen corresponderse con lo esperado, la discrepancia se debe tan solo al bajo número de particiones utilizadas
```{r}
pnorm(1.5)-pnorm(0)
```


Podemos ver como convergen las sumas inferior y superior a medida que aumenta el número de particiones

```{r}

vector_In <- double(0)
vector_Sn <- double(0)

for (n in 1:100){
  vector_In <- append(vector_In,integral_definida(dnorm,0,1.5,n)$In)
  vector_Sn <- append(vector_Sn,integral_definida(dnorm,0,1.5,n)$Sn)
}

df <- data.frame(n=1:100,
           Suma_inf=vector_In,
           Suma_sup=vector_Sn)
tail(df)
```
De hecho, gráficamente se ve que convergen mucho antes de que se llegue a las 100 particiones
```{r,fig,fig.width=6,echo=F}
plot(1:50,vector_In[1:50],pch=20,
     ylim=c(min(vector_In),max(vector_Sn)),
     xlab='n',
     ylab='Valor de la integral definida')
lines(1:50,vector_In[1:50])

points(1:50,vector_Sn[1:50]+0.001,pch=20,col='orange')
lines(1:50,vector_Sn[1:50],col='orange')

abline(h=pnorm(1.5)-pnorm(0),lty=2)
legend('topright',legend=c('Suma inferior In','Suma superior Sn'),
       col=c("black", "orange"),lty=1)

```

La línea discontinua representa el valor exacto de la integral. Los puntos correspondientes a la suma superior e inferior realmente se acaban solapando, pero para que se apreciase en el gráfico los he separado un poco.

Solo por curiosidad también puede verse cómo funciona cada método de integración numérica. Para compararlos adecuadamente,en el caso de la aproximación utilizando rectángulos se utiliza como estimación el promedio de la suma superior e inferior.

```{r,fig2,fig.width=6,echo=F}
vector_trap <- double(0)
vector_simp <- double(0)

for (n in 1:100){
  vector_trap <- append(vector_trap,integral_definida(dnorm,0,1.5,n,aprox='trap'))
  vector_simp <- append(vector_simp,integral_definida(dnorm,0,1.5,n,aprox='simp'))
}

vector_rect <- colMeans(matrix(rbind(vector_In,vector_Sn),nrow=2))

plot(1:50,vector_rect[1:50],pch=20,
     ylim=c(0.2,1),
     xlab='n',
     ylab='Valor de la integral definida')
lines(1:50,vector_rect[1:50])

points(1:50,vector_trap[1:50]+0.001,pch=20,col='orange')
lines(1:50,vector_trap[1:50],col='orange')

points(1:50,vector_simp[1:50]+0.001,pch=20,col='blue')
lines(1:50,vector_simp[1:50],col='blue')

abline(h=pnorm(1.5)-pnorm(0),lty=2)
legend('topright',legend=c('Rectángulos','Regla trapecios','Regla Simpson'),
       col=c("black", "orange","blue"),lty=1)
```

Si hacemos 'zoom' se ve que la regla de los trapecios y la regla de Simpson son mejores aproximaciones. Sin embargo, por algún motivo que no entiendo bien, la regla de Simpson produce un comportamiento extraño cuando el número de particiones es impar. Ofrece estimaciones peores.

```{r,fig3,fig3.width=6,echo=F}
plot(1:50,vector_rect[1:50],'l',
     ylim=c(0.4,0.45),
     xlab='n',
     ylab='Valor de la integral definida')
#lines(1:50,vector_rect[1:50])

#points(1:50,vector_trap[1:50],pch=20,col='orange')
lines(1:50,vector_trap[1:50],col='orange')

#points(1:50,vector_simp[1:50]+0.001,pch=20,col='blue')
lines(1:50,vector_simp[1:50],col='blue')

abline(h=pnorm(1.5)-pnorm(0),lty=2)
legend('bottomright',legend=c('Rectángulos','Regla trapecios','Regla Simpson'),
       col=c("black", "orange","blue"),lty=1)
```


